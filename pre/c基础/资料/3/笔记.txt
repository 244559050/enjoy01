=======================函数指针=====================
函数名是一个函数的首地址，所以我们可以将函数赋值给对应类型的函数指针

void 类型的指针：
类似：java object

指针变量都是4个字节。都是用十六进制表示。
void* -》 int * / char * /float*

下面两个表达式完全不同
int(*calc2)(void *a, void *); 函数指针
int* p(int a, int b); 一个返回值是int * 的函数
(int*) p(int a, int b)

=================================================================================
内存：
3区：
程序区
程序的二进制文件

静态存储区
全局变量和静态变量

动态存储区
  堆区：用于程序动态分配
  栈区：编译器自动分配，编译器自动申请和释放 2M
  
 void* malloc(size_t size)
 分配内存的单元是 字节， 大小 size，连续的内存
 如果申请失败，返回值是NULL
 
 void* calloc(size_t _Count,size_t _Size)
 申请 _Count 个 大小为_Size 的连续空间，这个连续空间的大小是_Size，如果申请失败，返回值是NULL
 而不是  _Count * size, 同时，它会初始化为0
 
 void * realloc（void * ptr, int len）; 
 

 动态申请的内存一定要收到释放
 free（*p）
 原则：不能重复释放
       必须赋值NULL
	   申请和释放一一对应
	   
===============================================字符串=============================================================
C 语言没有String
 
Char * str = “china”；
说明：是否可以修改str[2] = b;
不能修改str[2] = ‘b’
把“abc”赋值给一个字符指针变量时，如： char* ptr = “abc”；因为定义的是一个普通字符指针，
并没有定义空间来存放“abc”，所以编译器得帮我们先找个地方存放“abc”，显然，把这里的“abc”
当成常量并把它放到程序的常量区是编译器最合适的选择。所以的那个你去修改 char* ptr = “abc” 中的值，
如：ptr[0] = “g”的时候，会报错，因为这个地址里面存的是常量，常量是不能修改的。
Char *str = “Hello world”；
因为  “hello are you” 出现在一个表达式中时，“hello are you”使用的值就是这些字符所存储的地址（在常量区）。所以这个地址可以赋值给一个 char 类型的指针变量注意：“hello are you”作为字符数组初始化的时候就不是一个常量，其他情况下是一个常量。 

 
 作业：
 1 熟练使用动态分配内存函数和释放内存的函数
2. char *str = “hello world” 和 char str[20] = “hello world”; 区别总结？


	
 

